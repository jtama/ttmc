<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Project Aerial View</title>
    <style>
        body {
            font-family: sans-serif;
            margin: 0;
            overflow: hidden;
        }
        .links line {
            stroke-opacity: 0.6;
        }
        .nodes circle {
            stroke: #fff;
            stroke-width: 1.5px;
            cursor: pointer;
        }
        .node.selected {
            stroke: #000;
            stroke-width: 2px;
        }
        .node.fade, .links line.fade {
            opacity: 0.2;
        }
        .tooltip {
            position: absolute;
            text-align: left;
            padding: 8px;
            font: 12px sans-serif;
            background: #eee;
            border: 1px solid #999;
            border-radius: 8px;
            pointer-events: none;
            opacity: 0;
            transition: opacity 0.2s;
        }
        .legend {
            position: absolute;
            top: 20px;
            right: 20px;
            background: #fff;
            border: 1px solid #999;
            border-radius: 8px;
            padding: 10px;
            font: 12px sans-serif;
        }
        .legend-item {
            display: flex;
            align-items: center;
            margin-bottom: 5px;
        }
        .legend-color {
            width: 15px;
            height: 15px;
            margin-right: 5px;
        }
        .search {
            position: absolute;
            top: 20px;
            left: 20px;
        }
    </style>
</head>
<body>
<div class="search">
    <input type="text" id="search" placeholder="Search for a class...">
</div>
<script src="https://d3js.org/d3.v7.min.js"></script>
<script>
    const graphData = JSON.parse('{"nodes":[{"id":"TemplateExtensions","group":"","size":12},{"id":"java.util.Collection","group":"java.util","size":2},{"id":"io.quarkiverse.roq.frontmatter.runtime.model.Page","group":"io.quarkiverse.roq.frontmatter.runtime.model","size":2},{"id":"java.util.stream.Stream","group":"java.util.stream","size":2},{"id":"java.lang.String","group":"java.lang","size":2},{"id":"java.util.stream.Collectors","group":"java.util.stream","size":2},{"id":"io.quarkiverse.roq.frontmatter.runtime.model.RoqUrl","group":"io.quarkiverse.roq.frontmatter.runtime.model","size":2},{"id":"io.quarkiverse.roq.frontmatter.runtime.model.Site","group":"io.quarkiverse.roq.frontmatter.runtime.model","size":2},{"id":"io.quarkiverse.roq.frontmatter.runtime.model.RoqCollections","group":"io.quarkiverse.roq.frontmatter.runtime.model","size":2},{"id":"io.quarkiverse.roq.frontmatter.runtime.model.DocumentPage","group":"io.quarkiverse.roq.frontmatter.runtime.model","size":2},{"id":"java.util.Optional","group":"java.util","size":2},{"id":"java.util.ArrayList","group":"java.util","size":2}],"links":[{"source":"TemplateExtensions","target":"java.util.Collection","weight":4},{"source":"TemplateExtensions","target":"io.quarkiverse.roq.frontmatter.runtime.model.Page","weight":8},{"source":"TemplateExtensions","target":"java.util.stream.Stream","weight":8},{"source":"TemplateExtensions","target":"java.lang.String","weight":4},{"source":"TemplateExtensions","target":"java.util.stream.Collectors","weight":3},{"source":"TemplateExtensions","target":"io.quarkiverse.roq.frontmatter.runtime.model.RoqUrl","weight":4},{"source":"TemplateExtensions","target":"io.quarkiverse.roq.frontmatter.runtime.model.Site","weight":2},{"source":"TemplateExtensions","target":"io.quarkiverse.roq.frontmatter.runtime.model.RoqCollections","weight":2},{"source":"TemplateExtensions","target":"io.quarkiverse.roq.frontmatter.runtime.model.DocumentPage","weight":2},{"source":"TemplateExtensions","target":"java.util.Optional","weight":4},{"source":"TemplateExtensions","target":"java.util.ArrayList","weight":2}]}');

    const width = window.innerWidth;
    const height = window.innerHeight;

    // --- Tooltip ---
    const tooltip = d3.select("body").append("div")
        .attr("class", "tooltip");

    // --- Color Scale Fix ---
    // 1. Get all unique groups (packages) from the data.
    const allGroups = [...new Set(graphData.nodes.map(d => d.group))];
    // 2. Create a color scale with an explicit domain.
    const color = d3.scaleOrdinal(d3.schemeCategory10).domain(allGroups);

    // --- Legend ---
    const legend = d3.select("body").append("div")
        .attr("class", "legend");

    const legendItems = legend.selectAll(".legend-item")
        .data(allGroups)
        .enter().append("div")
        .attr("class", "legend-item");

    legendItems.append("div")
        .attr("class", "legend-color")
        .style("background-color", d => color(d));

    legendItems.append("input")
        .attr("type", "checkbox")
        .attr("checked", true)
        .on("change", (event, d) => {
            const visible = event.target.checked;
            node.filter(n => n.group === d).style("display", visible ? "block" : "none");
            link.filter(l => l.source.group === d || l.target.group === d).style("display", visible ? "block" : "none");
        });

    legendItems.append("span").text(d => d);

    const simulation = d3.forceSimulation(graphData.nodes)
        .force("link", d3.forceLink(graphData.links).id(d => d.id).distance(100))
        .force("charge", d3.forceManyBody().strength(-50))
        .force("center", d3.forceCenter(width / 2, height / 2));

    const svg = d3.select("body").append("svg")
        .attr("width", width)
        .attr("height", height);

    const hull = svg.append("g")
        .attr("class", "hulls");

    const defs = svg.append("defs");

    const link = svg.append("g")
        .attr("class", "links")
        .selectAll("line")
        .data(graphData.links)
        .enter().append("line")
        .attr("stroke-width", d => 1 + Math.sqrt(d.weight))
        .attr("stroke", d => {
            const id = `gradient-${d.source.id}-${d.target.id}`.replace(/[^a-zA-Z0-9]/g, "-");
            const gradient = defs.append("linearGradient")
                .attr("id", id)
                .attr("x1", "0%").attr("y1", "0%").attr("x2", "100%").attr("y2", "0%");
            // 3. Use the robust color scale for gradients.
            gradient.append("stop").attr("offset", "0%").attr("stop-color", color(d.source.group));
            gradient.append("stop").attr("offset", "100%").attr("stop-color", color(d.target.group));
            return `url(#${id})`;
        })
        .on("mouseover", function(event, d) {
            tooltip.style("opacity", .9);
            tooltip.html(`Source: ${d.source.id}<br/>Target: ${d.target.id}<br/>Interactions: ${d.weight}`)
                .style("left", (event.pageX + 10) + "px")
                .style("top", (event.pageY - 28) + "px");
        })
        .on("mouseout", function(d) {
            tooltip.style("opacity", 0);
        });

    const node = svg.append("g")
        .attr("class", "nodes")
        .selectAll("circle")
        .data(graphData.nodes)
        .enter().append("circle")
        .attr("r", d => 5 + d.size / 2)
        // 4. Use the robust color scale for node fills.
        .attr("fill", d => color(d.group))
        .call(d3.drag()
            .on("start", dragstarted)
            .on("drag", dragged)
            .on("end", dragended))
        .on("mouseover", function(event, d) {
            tooltip.style("opacity", .9);
            tooltip.html(`ID: ${d.id}<br/>Group: ${d.group}<br/>Connections: ${d.size}`)
                .style("left", (event.pageX + 10) + "px")
                .style("top", (event.pageY - 28) + "px");
        })
        .on("mouseout", function(d) {
            tooltip.style("opacity", 0);
        })
        .on('click', clickHandler)
        .on('dblclick', dblClickHandler);

    let selectedNode = null;

    function clickHandler(event, d) {
        if (selectedNode === d) {
            selectedNode = null;
            node.classed('fade', false).classed('selected', false);
            link.classed('fade', false);
        } else {
            selectedNode = d;
            const linkedNodes = new Set();
            linkedNodes.add(d.id);
            graphData.links.forEach(l => {
                if (l.source.id === d.id) linkedNodes.add(l.target.id);
                if (l.target.id === d.id) linkedNodes.add(l.source.id);
            });

            node.classed('fade', n => !linkedNodes.has(n.id));
            node.classed('selected', n => n.id === d.id);
            link.classed('fade', l => l.source.id !== d.id && l.target.id !== d.id);
        }
    }

    function dblClickHandler(event, d) {
        if (d.fx === null) {
            d.fx = d.x;
            d.fy = d.y;
        } else {
            d.fx = null;
            d.fy = null;
        }
    }

    d3.select("#search").on("input", function() {
        const searchTerm = this.value.toLowerCase();
        node.style("opacity", n => n.id.toLowerCase().includes(searchTerm) ? 1 : 0.1);
        link.style("opacity", l => l.source.id.toLowerCase().includes(searchTerm) || l.target.id.toLowerCase().includes(searchTerm) ? 1 : 0.1);
    });

    simulation
        .nodes(graphData.nodes)
        .on("tick", ticked);

    simulation.force("link")
        .links(graphData.links);

    function ticked() {
        link
            .attr("x1", d => d.source.x)
            .attr("y1", d => d.source.y)
            .attr("x2", d => d.target.x)
            .attr("y2", d => d.target.y);

        node
            .attr("cx", d => {
                const radius = 5 + d.size / 2;
                return d.x = Math.max(radius, Math.min(width - radius, d.x));
            })
            .attr("cy", d => {
                const radius = 5 + d.size / 2;
                return d.y = Math.max(radius, Math.min(height - radius, d.y));
            });

        const hulls = {};
        graphData.nodes.forEach(n => {
            if (!hulls[n.group]) {
                hulls[n.group] = [];
            }
            hulls[n.group].push([n.x, n.y]);
        });

        const hullData = Object.keys(hulls).map(group => {
            return {group: group, path: d3.polygonHull(hulls[group])};
        });

        hull.selectAll("path")
            .data(hullData)
            .join("path")
            .attr("d", d => `M${d.path.join("L")}Z`)
            .attr("fill", d => color(d.group))
            .attr("opacity", 0.2);
    }

    function dragstarted(event, d) {
        if (!event.active) simulation.alphaTarget(0.3).restart();
        d.fx = d.x;
        d.fy = d.y;
    }

    function dragged(event, d) {
        d.fx = event.x;
        d.fy = event.y;
    }

    function dragended(event, d) {
        if (!event.active) simulation.alphaTarget(0);
        d.fx = null;
        d.fy = null;
    }
</script>
</body>
</html>